---

title: "python开发PDF处理工具的4个不同阶段"
categories: 博客
tags:
    - 技术
permalink: /posts/:title.html
toc: true

---

# 基于python，PDF工具箱不同开发阶段的代码实现

需求导向型，结果导向型。工具，是服务于最终用户的需求的。



## python安装：

去python官网，下载并安装python可执行程序。

## 依赖安装：

```python
pip install PyQt5 PyMuPDF PyPDF2 pikepdf Pillow
```

## 各阶段实现代码：

### 1.PDF解密工具开发代码

```python
import sys
import os
from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QTabWidget, QVBoxLayout, QHBoxLayout,
                             QLabel, QPushButton, QLineEdit, QFileDialog, QMessageBox, QListWidget, 
                             QListWidgetItem, QAbstractItemView, QComboBox)
from PyQt5.QtCore import Qt, QMimeData
from PyPDF2 import PdfReader, PdfWriter, PdfMerger
from pikepdf import Pdf, Encryption, Permissions


class DragDropLineEdit(QLineEdit):
    """支持PDF拖放的自定义输入框（基于网页1/2实现）"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAcceptDrops(True)

    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls():
            for url in event.mimeData().urls():
                if url.isLocalFile() and url.toLocalFile().lower().endswith('.pdf'):
                    event.acceptProposedAction()
                    return
        event.ignore()

    def dropEvent(self, event):
        for url in event.mimeData().urls():
            file_path = url.toLocalFile()
            if file_path.lower().endswith('.pdf'):
                self.setText(file_path)
                break

class PDFToolsUI(QMainWindow):
    """PDF全能处理工具主界面"""
    def __init__(self):
        super().__init__()
        self.setWindowTitle("PDF解密小工具 v1.0")
        self.setGeometry(300, 300, 800, 500)
        self.init_ui()

    def init_ui(self):
        """界面初始化"""
        tabs = QTabWidget()
        self.setCentralWidget(tabs)

        # 解密模块
        decrypt_tab = QWidget()
        self.decrypt_ui(decrypt_tab)
        tabs.addTab(decrypt_tab, "密码解除")

        # 加密模块
        encrypt_tab = QWidget()
        self.encrypt_ui(encrypt_tab)
        tabs.addTab(encrypt_tab, "文件加密")

        # 合并模块
        merge_tab = QWidget()
        self.merge_ui(merge_tab)
        tabs.addTab(merge_tab, "文件合并")

    def decrypt_ui(self, tab):
        """密码解除界面"""
        layout = QVBoxLayout()

        # 文件选择（支持拖放）
        file_layout = QHBoxLayout()
        self.decrypt_input = DragDropLineEdit()
        btn_choose = QPushButton("选择文件")
        btn_choose.clicked.connect(lambda: self.choose_file(self.decrypt_input))

        file_layout.addWidget(QLabel("输入文件:"))
        file_layout.addWidget(self.decrypt_input)
        file_layout.addWidget(btn_choose)

        # 密码输入
        self.decrypt_pass = QLineEdit()
        self.decrypt_pass.setEchoMode(QLineEdit.Password)

        # 操作按钮
        btn_decrypt = QPushButton("开始解密")
        btn_decrypt.clicked.connect(self.handle_decrypt)

        layout.addLayout(file_layout)
        layout.addWidget(QLabel("输入密码:"))
        layout.addWidget(self.decrypt_pass)
        layout.addWidget(btn_decrypt)
        tab.setLayout(layout)

    def encrypt_ui(self, tab):
        """文件加密界面"""
        layout = QVBoxLayout()

        # 输入文件选择（支持拖放）
        input_layout = QHBoxLayout()
        self.encrypt_input = DragDropLineEdit()
        btn_input = QPushButton("选择文件")
        btn_input.clicked.connect(lambda: self.choose_file(self.encrypt_input))
        input_layout.addWidget(QLabel("输入文件:"))
        input_layout.addWidget(self.encrypt_input)
        input_layout.addWidget(btn_input)

        # 输出路径选择
        output_layout = QHBoxLayout()
        self.encrypt_output = QLineEdit()
        btn_output = QPushButton("另存为")
        btn_output.clicked.connect(self.choose_output)
        output_layout.addWidget(QLabel("输出路径:"))
        output_layout.addWidget(self.encrypt_output)
        output_layout.addWidget(btn_output)

        # 加密参数
        param_layout = QHBoxLayout()
        self.encrypt_pass = QLineEdit()
        self.encrypt_pass.setEchoMode(QLineEdit.Password)
        self.encrypt_algo = QComboBox()
        self.encrypt_algo.addItems(["AES-128", "AES-256"])

        param_layout.addWidget(QLabel("加密密码:"))
        param_layout.addWidget(self.encrypt_pass)
        param_layout.addWidget(QLabel("算法:"))
        param_layout.addWidget(self.encrypt_algo)

        # 操作按钮
        btn_encrypt = QPushButton("开始加密")
        btn_encrypt.clicked.connect(self.handle_encrypt)

        layout.addLayout(input_layout)
        layout.addLayout(output_layout)
        layout.addLayout(param_layout)
        layout.addWidget(btn_encrypt)
        tab.setLayout(layout)

    def merge_ui(self, tab):
        """文件合并界面（支持拖放添加文件）"""
        layout = QVBoxLayout()

        # 文件列表（基于网页3实现拖放）
        self.merge_list = QListWidget()
        self.merge_list.setDragDropMode(QAbstractItemView.InternalMove)
        self.merge_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.merge_list.setAcceptDrops(True)
        self.merge_list.dragEnterEvent = self.merge_drag_enter
        self.merge_list.dropEvent = self.merge_drop

        # 操作按钮
        btn_layout = QHBoxLayout()
        btn_add = QPushButton("添加文件")
        btn_add.clicked.connect(self.add_merge_files)
        btn_remove = QPushButton("移除选中")
        btn_remove.clicked.connect(lambda: self.remove_items(self.merge_list))
        btn_up = QPushButton("上移")
        btn_up.clicked.connect(lambda: self.move_item(self.merge_list, -1))
        btn_down = QPushButton("下移")
        btn_down.clicked.connect(lambda: self.move_item(self.merge_list, 1))

        btn_layout.addWidget(btn_add)
        btn_layout.addWidget(btn_remove)
        btn_layout.addWidget(btn_up)
        btn_layout.addWidget(btn_down)

        # 输出路径
        output_layout = QHBoxLayout()
        self.merge_output = QLineEdit()
        btn_output = QPushButton("选择路径")
        btn_output.clicked.connect(self.choose_merge_output)
        output_layout.addWidget(QLabel("输出文件:"))
        output_layout.addWidget(self.merge_output)
        output_layout.addWidget(btn_output)

        # 合并按钮
        btn_merge = QPushButton("开始合并")
        btn_merge.clicked.connect(self.handle_merge)

        layout.addWidget(self.merge_list)
        layout.addLayout(btn_layout)
        layout.addLayout(output_layout)
        layout.addWidget(btn_merge)
        tab.setLayout(layout)

    # 核心功能方法（确保所有槽函数存在）
    def handle_decrypt(self):
        """解密处理（网页2验证）"""
        input_path = self.decrypt_input.text()
        password = self.decrypt_pass.text()

        if not os.path.exists(input_path):
            QMessageBox.critical(self, "错误", "文件不存在！")
            return

        output_path = f"{os.path.splitext(input_path)[0]}_unlocked.pdf"

        try:
            with Pdf.open(input_path, password=password) as pdf:
                pdf.save(output_path)
            QMessageBox.information(self, "成功", f"文件已保存至:\n{output_path}")
        except Exception as e:
            QMessageBox.critical(self, "错误", f"解密失败:\n{str(e)}")

    def handle_encrypt(self):
        """加密处理"""
        input_path = self.encrypt_input.text()
        output_path = self.encrypt_output.text()
        password = self.encrypt_pass.text()

        # 检查输入文件是否存在
        if not os.path.exists(input_path):
            QMessageBox.critical(self, "错误", f"输入文件不存在: {input_path}")
            return

        if not all([input_path, output_path, password]):
            QMessageBox.critical(self, "错误", "请填写所有字段！")
            return

        try:
            # 使用PyPDF2进行加密
            reader = PdfReader(input_path)
            writer = PdfWriter()

            # 复制所有页面
            for page in reader.pages:
                writer.add_page(page)

            # 设置加密
            writer.encrypt(password)

            # 确保输出目录存在
            output_dir = os.path.dirname(output_path)
            if output_dir and not os.path.exists(output_dir):
                os.makedirs(output_dir)

            # 保存加密后的文件
            with open(output_path, "wb") as f:
                writer.write(f)

            QMessageBox.information(self, "成功", "文件加密完成！")
        except Exception as e:
            QMessageBox.critical(self, "错误", f"加密失败:\n{str(e)}")





    def handle_merge(self):
        """合并处理"""
        output_path = self.merge_output.text()
        if not output_path:
            QMessageBox.critical(self, "错误", "请选择输出路径！")
            return

        merger = PdfMerger()
        try:
            for i in range(self.merge_list.count()):
                file_path = self.merge_list.item(i).text()
                merger.append(file_path)

            merger.write(output_path)
            QMessageBox.information(self, "成功", "文件合并完成！")
        except Exception as e:
            QMessageBox.critical(self, "错误", f"合并失败:\n{str(e)}")
        finally:
            merger.close()

    # 通用工具方法
    def choose_file(self, target_field):
        """文件选择对话框"""
        path, _ = QFileDialog.getOpenFileName(
            self, "选择PDF文件", "", "PDF文件 (*.pdf)")
        if path:
            target_field.setText(path)

    def choose_output(self):
        """加密输出路径选择"""
        path, _ = QFileDialog.getSaveFileName(
            self, "保存文件", "", "PDF文件 (*.pdf)")
        if path:
            self.encrypt_output.setText(path)

    def choose_merge_output(self):
        """合并输出路径选择"""
        path, _ = QFileDialog.getSaveFileName(
            self, "保存合并文件", "", "PDF文件 (*.pdf)")
        if path:
            self.merge_output.setText(path)

    def add_merge_files(self):
        """添加合并文件"""
        files, _ = QFileDialog.getOpenFileNames(
            self, "选择PDF文件", "", "PDF文件 (*.pdf)")
        if files:
            for f in files:
                item = QListWidgetItem(f)
                self.merge_list.addItem(item)

    def remove_items(self, list_widget):
        """移除选中项"""
        for item in list_widget.selectedItems():
            list_widget.takeItem(list_widget.row(item))

    def move_item(self, list_widget, direction):
        """调整顺序"""
        current_row = list_widget.currentRow()
        if current_row >= 0:
            new_row = current_row + direction
            if 0 <= new_row < list_widget.count():
                item = list_widget.takeItem(current_row)
                list_widget.insertItem(new_row, item)
                list_widget.setCurrentRow(new_row)

    # 合并列表拖放事件（基于网页3实现）
    def merge_drag_enter(self, event):
        if event.mimeData().hasUrls():
            for url in event.mimeData().urls():
                if url.isLocalFile() and url.toLocalFile().lower().endswith('.pdf'):
                    event.acceptProposedAction()
                    return
        event.ignore()

    def merge_drop(self, event):
        for url in event.mimeData().urls():
            file_path = url.toLocalFile()
            if file_path.lower().endswith('.pdf'):
                self.merge_list.addItem(QListWidgetItem(file_path))

if __name__ == '__main__':
    app = QApplication(sys.argv)
    window = PDFToolsUI()
    window.show()
    sys.exit(app.exec_())
```



### 2.PDF提取及导出为图片开发代码

```python
import sys
import os
import fitz
from PyQt5.QtWidgets import (QApplication, QMainWindow, QFileDialog, QMessageBox,
                             QLabel, QLineEdit, QComboBox, QRadioButton, QPushButton,
                             QHBoxLayout, QVBoxLayout, QGroupBox, QWidget)
from PyQt5.QtCore import QThread, pyqtSignal, Qt
from PyQt5.QtGui import QDragEnterEvent, QDropEvent

class WorkerThread(QThread):
    finished = pyqtSignal(bool, str)
    error = pyqtSignal(str)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.params = {
            'dpi': 300,
            'alpha': False,
            'colorspace': fitz.csRGB,
            'output_dir': ''  # 添加默认的输出目录
        }

    def set_params(self, file_path, output_dir, pages, export_pdf, img_format, dpi):
        self.params.update({
            'file_path': file_path,
            'output_dir': output_dir,
            'pages': self._parse_pages(pages),
            'export_pdf': export_pdf,
            'img_format': img_format.lower(),
            'dpi': dpi,
            'alpha': (img_format.lower() == 'png')
        })

    def _parse_pages(self, pages_str):
        pages = []
        for part in pages_str.replace('，', ',').split(','):
            part = part.strip()
            if not part:
                continue
            if '-' in part:
                start_end = part.split('-')
                if len(start_end) != 2:
                    raise ValueError("无效的页码范围格式")
                start = int(start_end[0])
                end = int(start_end[1])
                pages.extend(range(start, end+1))
            else:
                pages.append(int(part))
        return sorted(set(pages))

    def run(self):
        try:
            doc = fitz.open(self.params['file_path'])
            total_pages = doc.page_count

            valid_pages = [p-1 for p in self.params['pages'] if 0 < p <= total_pages]
            if not valid_pages:
                raise ValueError("所有页码均超出文档范围")

            if self.params['export_pdf']:
                self._export_pdf(doc, valid_pages)
            else:
                self._export_images(doc, valid_pages)

            doc.close()
            self.finished.emit(True, self.params['output_dir'])

        except Exception as e:
            self.error.emit(str(e))

    def _export_pdf(self, doc, pages):
        new_doc = fitz.open()
        for p in pages:
            new_doc.insert_pdf(doc, from_page=p, to_page=p)
        output_path = os.path.join(self.params['output_dir'], 'extracted.pdf')
        new_doc.save(output_path, garbage=3, deflate=True)
        new_doc.close()

    def _export_images(self, doc, pages):
        for idx, p in enumerate(pages):
            page = doc[p]
            # 修正抗锯齿参数名称
            pix = page.get_pixmap(
                dpi=self.params['dpi'],
                alpha=self.params['alpha'],
                colorspace=self.params['colorspace'],
                annots=True,
                # anti_aliasing=True  # 参数名改为下划线形式
            )
            output_path = os.path.join(
                self.params['output_dir'],
                f'page_{p+1}_dpi{self.params["dpi"]}.{self.params["img_format"]}'
            )
            if self.params['img_format'] == 'jpg':
                pix.save(output_path, jpg_quality=95)
            else:
                pix.save(output_path)

class PdfToolApp(QMainWindow):
    def __init__(self):
        super().__init__()
        self.init_ui()
        self.worker = WorkerThread()
        self._connect_signals()
        self.setAcceptDrops(True)

    def init_ui(self):
        self.setWindowTitle('PDF文档提取及导出图片小工具 v1.0')
        self.setGeometry(300, 300, 600, 320)

        # 文件选择组
        file_group = QGroupBox("文件操作")
        self.txt_file = QLineEdit()
        self.txt_file.setPlaceholderText("拖拽PDF文件到此或点击浏览...")
        btn_browse = QPushButton("浏览")
        btn_browse.clicked.connect(self._browse_file)

        # 输出设置组
        output_group = QGroupBox("输出设置")
        self.txt_output = QLineEdit()
        btn_output = QPushButton("选择目录")
        btn_output.clicked.connect(self._browse_dir)
        self.rad_pdf = QRadioButton("导出为PDF")
        self.rad_img = QRadioButton("导出为图片")
        self.rad_pdf.setChecked(True)
        self.cmb_format = QComboBox()
        self.cmb_format.addItems(['PNG', 'JPG'])
        self.cmb_dpi = QComboBox()
        self.cmb_dpi.addItems(['150 (网页)', '300 (印刷)', '600 (高清)'])
        self.txt_pages = QLineEdit()
        self.txt_pages.setPlaceholderText("输入页码范围（如：1-3 或 1,3,5）")

        # 布局
        file_layout = QHBoxLayout()
        file_layout.addWidget(QLabel("PDF文件:"))
        file_layout.addWidget(self.txt_file)
        file_layout.addWidget(btn_browse)
        file_group.setLayout(file_layout)

        output_layout = QVBoxLayout()
        output_layout.addWidget(QLabel("输出目录:"))
        output_layout.addWidget(self.txt_output)
        output_layout.addWidget(btn_output)

        pages_layout = QHBoxLayout()
        pages_layout.addWidget(QLabel("页码范围:"))
        pages_layout.addWidget(self.txt_pages)

        format_layout = QHBoxLayout()
        format_layout.addWidget(self.rad_pdf)
        format_layout.addWidget(self.rad_img)
        format_layout.addWidget(self.cmb_format)
        format_layout.addWidget(QLabel("DPI:"))
        format_layout.addWidget(self.cmb_dpi)

        output_group.setLayout(output_layout)
        output_layout.addLayout(pages_layout)
        output_layout.addLayout(format_layout)

        # 主布局
        main_layout = QVBoxLayout()
        main_layout.addWidget(file_group)
        main_layout.addWidget(output_group)

        central_widget = QWidget()
        central_widget.setLayout(main_layout)
        self.setCentralWidget(central_widget)

    def _connect_signals(self):
        # 确保初始状态下，如果选择了PDF导出，则禁用格式选择
        self.cmb_format.setEnabled(self.rad_img.isChecked())

        self.rad_pdf.toggled.connect(lambda: self.cmb_format.setEnabled(False))
        self.rad_img.toggled.connect(lambda: self.cmb_format.setEnabled(True))

        btn_execute = QPushButton("开始转换", self)
        btn_execute.clicked.connect(self._start_conversion)
        self.centralWidget().layout().addWidget(btn_execute)

        self.worker.finished.connect(self._on_finished)
        self.worker.error.connect(self._show_error)

    def dragEnterEvent(self, event: QDragEnterEvent):
        if event.mimeData().hasUrls():
            event.acceptProposedAction()

    def dropEvent(self, event: QDropEvent):
        for url in event.mimeData().urls():
            if url.isLocalFile() and url.fileName().lower().endswith('.pdf'):
                # 使用 os.path.normpath 统一路径分隔符
                self.txt_file.setText(os.path.normpath(url.toLocalFile()))
                break

    def _browse_file(self):
        path, _ = QFileDialog.getOpenFileName(self, "选择PDF文件", "", "PDF Files (*.pdf)")
        if path:
            self.txt_file.setText(path)

    def _browse_dir(self):
        path = QFileDialog.getExistingDirectory(self, "选择输出目录")
        if path:
            self.txt_output.setText(path)

    def _start_conversion(self):
        params = {
            'file_path': self.txt_file.text(),
            'output_dir': self.txt_output.text(),
            'pages': self.txt_pages.text() or "1-1",
            'export_pdf': self.rad_pdf.isChecked(),
            'img_format': self.cmb_format.currentText(),
            'dpi': int(self.cmb_dpi.currentText().split()[0])
        }

        if not os.path.exists(params['file_path']):
            QMessageBox.warning(self, "错误", "PDF文件路径无效")
            return

        if not os.path.exists(params['output_dir']):
            os.makedirs(params['output_dir'], exist_ok=True)

        try:
            _ = self.worker._parse_pages(params['pages'])
        except ValueError as e:
            QMessageBox.critical(self, "输入错误", f"页码格式错误：{str(e)}")
            return

        self.worker.set_params(**params)
        self.worker.start()

    def _on_finished(self, success, output_dir):
        QMessageBox.information(self, "完成", f"文件已保存至：\n{output_dir}")

    def _show_error(self, msg):
        QMessageBox.critical(self, "错误", f"处理失败：{msg}")

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = PdfToolApp()
    window.show()
    sys.exit(app.exec_())

```



### 3.图片合成PDF开发代码

```python
import sys
import os
import re
from concurrent.futures import ThreadPoolExecutor
from PIL import Image, ImageOps
from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout,
                            QHBoxLayout, QPushButton, QFileDialog, QListWidget,
                            QLabel, QProgressDialog, QGroupBox, QCheckBox,
                            QSlider, QComboBox, QMessageBox, QSplitter,
                            QListWidgetItem)
from PyQt5.QtCore import Qt, QDir, QSize
from PyQt5.QtGui import QPixmap, QImage

class ImageToPDFConverter(QMainWindow):
    def __init__(self):
        super().__init__()
        self.preview_size = QSize(300, 400)  # 保持QSize定义
        self.image_files = []
        self.current_dir = ""
        self.settings = {
            'resolution': 300,
            'compression': 75,
            'page_size': '原始尺寸',
            'auto_rotate': True
        }
        self.init_ui()

    def init_ui(self):
        self.setWindowTitle('图片转PDF工具')
        self.setGeometry(300, 300, 1000, 600)

        main_widget = QWidget()
        self.setCentralWidget(main_widget)
        main_layout = QHBoxLayout(main_widget)

        splitter = QSplitter(Qt.Horizontal)

        # 左侧面板
        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)

        # 文件管理区域
        dir_group = QGroupBox("文件管理")
        dir_layout = QVBoxLayout(dir_group)
        self.btn_choose = QPushButton("选择目录")
        self.btn_choose.clicked.connect(self.choose_directory)
        self.lbl_dir = QLabel("未选择目录")

        btn_group = QHBoxLayout()
        self.btn_add_files = QPushButton("添加文件")
        self.btn_remove_selected = QPushButton("移除选中")
        self.btn_clear_list = QPushButton("清空列表")
        btn_group.addWidget(self.btn_add_files)
        btn_group.addWidget(self.btn_remove_selected)
        btn_group.addWidget(self.btn_clear_list)

        dir_layout.addWidget(self.btn_choose)
        dir_layout.addWidget(self.lbl_dir)
        dir_layout.addLayout(btn_group)

        # 文件列表
        self.list_widget = QListWidget()
        self.list_widget.setDragDropMode(QListWidget.InternalMove)
        self.list_widget.itemSelectionChanged.connect(self.show_preview)

        # 设置区域
        settings_group = QGroupBox("转换设置")
        settings_layout = QVBoxLayout(settings_group)
        self.page_size_combo = QComboBox()
        self.page_size_combo.addItems(["原始尺寸", "A4 (210x297mm)", "Letter (216x279mm)"])
        self.compression_check = QCheckBox("启用压缩")
        self.compression_slider = QSlider(Qt.Horizontal)
        self.compression_slider.setRange(1, 100)
        self.compression_slider.setValue(75)
        self.rotate_check = QCheckBox("自动旋转")
        self.rotate_check.setChecked(True)

        settings_layout.addWidget(QLabel("页面尺寸:"))
        settings_layout.addWidget(self.page_size_combo)
        settings_layout.addWidget(self.compression_check)
        settings_layout.addWidget(self.compression_slider)
        settings_layout.addWidget(self.rotate_check)

        # 组装左侧布局
        left_layout.addWidget(dir_group)
        left_layout.addWidget(QLabel("文件列表:"))
        left_layout.addWidget(self.list_widget)
        left_layout.addWidget(settings_group)

        # 右侧预览区域
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)
        self.preview_label = QLabel("预览区域")
        self.preview_label.setAlignment(Qt.AlignCenter)
        self.preview_label.setFixedSize(self.preview_size)  # 正确使用QSize
        right_layout.addWidget(self.preview_label)

        # 转换按钮
        self.btn_convert = QPushButton("开始转换")
        self.btn_convert.clicked.connect(self.convert_to_pdf)
        left_layout.addWidget(self.btn_convert)

        # 连接按钮事件
        self.btn_add_files.clicked.connect(self.add_single_file)
        self.btn_remove_selected.clicked.connect(self.remove_selected_files)
        self.btn_clear_list.clicked.connect(self.clear_file_list)

        splitter.addWidget(left_panel)
        splitter.addWidget(right_panel)
        main_layout.addWidget(splitter)

    def show_preview(self):
        """修复尺寸转换错误的预览方法"""
        if not self.list_widget.currentItem():
            self.preview_label.clear()
            return

        try:
            # 获取完整路径
            filename = self.list_widget.currentItem().text()
            full_path = os.path.join(self.current_dir, filename) if self.current_dir else filename

            with Image.open(full_path) as img:
                # 自动旋转
                if self.settings['auto_rotate']:
                    img = ImageOps.exif_transpose(img)

                # 修复：将QSize转换为元组
                thumbnail_size = (
                    self.preview_size.width(), 
                    self.preview_size.height()
                )
                img.thumbnail(thumbnail_size)  # 使用元组参数

                # 处理透明通道
                if img.mode == 'RGBA':
                    background = Image.new('RGB', img.size, (255, 255, 255))
                    background.paste(img, mask=img.split()[3])
                    img = background
                elif img.mode not in ['RGB', 'L']:
                    img = img.convert('RGB')

                # 转换为QImage
                if img.mode == 'RGB':
                    format = QImage.Format_RGB888
                    bytes_per_line = img.width * 3
                elif img.mode == 'L':
                    format = QImage.Format_Grayscale8
                    bytes_per_line = img.width
                else:
                    format = QImage.Format_RGBA8888
                    bytes_per_line = img.width * 4

                qimg = QImage(img.tobytes(), img.width, img.height, 
                            bytes_per_line, format)

                # 保持宽高比缩放
                pixmap = QPixmap.fromImage(qimg).scaled(
                    self.preview_size.width(), 
                    self.preview_size.height(),
                    Qt.KeepAspectRatio,
                    Qt.SmoothTransformation
                )
                self.preview_label.setPixmap(pixmap)

        except Exception as e:
            QMessageBox.warning(self, "预览错误", f"{str(e)}")
            self.preview_label.setText("预览不可用")

    # 其他保持不变的方法...
    def choose_directory(self):
        directory = QFileDialog.getExistingDirectory(self, "选择目录", QDir.homePath())
        if directory:
            self.current_dir = directory
            self.lbl_dir.setText(directory)
            self.scan_image_files(directory)

    def scan_image_files(self, directory):
        valid_ext = ['.jpg', '.jpeg', '.png', '.bmp', '.tiff', '.webp']

        def natural_sort(s):
            return [int(c) if c.isdigit() else c.lower() for c in re.split(r'(\d+)', s)]

        files = sorted(
            [f for f in os.listdir(directory) if os.path.splitext(f)[1].lower() in valid_ext],
            key=natural_sort
        )
        self.image_files = files
        self.update_file_list()

    def update_file_list(self):
        self.list_widget.clear()
        for f in self.image_files:
            item = QListWidgetItem(f)
            item.setFlags(item.flags() | Qt.ItemIsUserCheckable)
            item.setCheckState(Qt.Checked)
            self.list_widget.addItem(item)

    def add_single_file(self):
        files, _ = QFileDialog.getOpenFileNames(self, "选择文件", 
            self.current_dir or QDir.homePath(),
            "图片文件 (*.jpg *.jpeg *.png *.bmp *.tiff *.webp)")
        if files:
            if self.current_dir:
                new_files = [os.path.relpath(f, self.current_dir) for f in files]
            else:
                new_files = files
                self.current_dir = os.path.dirname(files[0])
                self.lbl_dir.setText(self.current_dir)

            self.image_files.extend(new_files)
            self.update_file_list()

    def remove_selected_files(self):
        selected = sorted([self.list_widget.row(item) for item in self.list_widget.selectedItems()], reverse=True)
        for row in selected:
            del self.image_files[row]
        self.update_file_list()

    def clear_file_list(self):
        self.image_files.clear()
        self.list_widget.clear()

    def convert_to_pdf(self):
        if not self.image_files:
            QMessageBox.warning(self, "错误", "请先添加图片文件")
            return

        save_path, _ = QFileDialog.getSaveFileName(self, "保存PDF", 
                                                 QDir.homePath(), 
                                                 "PDF文件 (*.pdf)")
        if not save_path:
            return

        files = [os.path.join(self.current_dir, f) for f in self.get_checked_files()]

        progress = QProgressDialog("转换中...", "取消", 0, len(files), self)
        progress.setWindowModality(Qt.WindowModal)

        try:
            with ThreadPoolExecutor() as executor:
                futures = []
                images = []

                for file_path in files:
                    futures.append(executor.submit(self.process_image, file_path))

                for i, future in enumerate(futures):
                    if progress.wasCanceled():
                        break
                    progress.setValue(i)
                    img = future.result()
                    if img:
                        images.append(img)

                if images:
                    images[0].save(save_path, "PDF", 
                                 resolution=self.settings['resolution'],
                                 save_all=True, 
                                 append_images=images[1:],
                                 quality=self.settings['compression'])
                    QMessageBox.information(self, "完成", "转换成功!")
        except Exception as e:
            QMessageBox.critical(self, "错误", f"转换失败: {str(e)}")
        finally:
            progress.close()

    def process_image(self, file_path):
        try:
            img = Image.open(file_path)
            if self.settings['auto_rotate']:
                img = ImageOps.exif_transpose(img)

            img = self.resize_image(img)
            if img.mode != 'RGB':
                img = img.convert('RGB')
            return img
        except Exception as e:
            QMessageBox.warning(self, "错误", f"处理失败: {os.path.basename(file_path)}\n{str(e)}")
            return None

    def resize_image(self, img):
        size_map = {
            'A4 (210x297mm)': (2480, 3508),
            'Letter (216x279mm)': (2550, 3300)
        }
        target = self.settings['page_size']

        if target == '原始尺寸':
            return img

        if target in size_map:
            img.thumbnail(size_map[target])
        return img

    def get_checked_files(self):
        return [self.list_widget.item(i).text() 
               for i in range(self.list_widget.count())
               if self.list_widget.item(i).checkState() == Qt.Checked]

if __name__ == '__main__':
    # 高DPI设置
    if hasattr(Qt, 'AA_EnableHighDpiScaling'):
        QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
    if hasattr(Qt, 'AA_UseHighDpiPixmaps'):
        QApplication.setAttribute(Qt.AA_UseHighDpiPixmaps, True)

    app = QApplication(sys.argv)
    window = ImageToPDFConverter()
    window.show()
    sys.exit(app.exec_())
```



### 4.功能多合一及添加标签处理功能开发代码

```python

```
